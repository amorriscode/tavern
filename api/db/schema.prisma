datasource DS {
  // optionally set multiple providers
  // example: provider = ["sqlite", "postgresql"]
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = "native"
}

model Difficulty {
  name        String    @id
  color       String
  description String
  Problem     Problem[]
}

model TestCase {
  id        Int     @id @default(autoincrement())
  problem   Problem @relation(fields: [problemId], references: [id])
  problemId Int
  input     String
  output    String
}

enum Language {
  JAVASCRIPT
}

model Scaffold {
  id        String   @id
  problem   Problem  @relation(fields: [problemId], references: [id])
  problemId Int
  body      String
  language  Language
}

model Problem {
  id               Int               @id
  name             String
  description      String
  difficulty       Difficulty        @relation(fields: [difficultyName], references: [name])
  difficultyName   String
  hints            String[]
  sampleInput      String
  sampleOutput     String
  testCases        TestCase[]
  scaffolds        Scaffold[]
  checksum         String?
  assignedProblems AssignedProblem[]
}

model Guild {
  id               String            @id @default(uuid())
  name             String
  experience       Int               @default(0)
  createdAt        DateTime          @default(now())
  transactions     Transaction[]
  users            User[]
  assignedProblems AssignedProblem[]
}

model AssignedProblem {
  id        String   @id @default(uuid())
  problem   Problem  @relation(fields: [problemId], references: [id])
  problemId Int
  guild     Guild?   @relation(fields: [guildId], references: [id])
  guildId   String?
  createdAt DateTime @default(now())
}

// experience transactions
model Transaction {
  id      String   @id @default(uuid())
  guild   Guild?   @relation(fields: [guildId], references: [id])
  guildId String?
  delta   Int
  result  Int // total experience after delta
  time    DateTime @default(now())
  // todo: user id
  // transactions can exist for both users + guilds
}

model User {
  id      String  @id @default(uuid())
  name    String
  email   String  @unique
  guild   Guild?  @relation(fields: [guildId], references: [id])
  guildId String?
  level   Int
  title   Title   @relation(fields: [titleId], references: [id])
  titleId String
}

model Title {
  id          String @id @default(uuid())
  name        String
  users       User[]
  unlockLevel Int
}
