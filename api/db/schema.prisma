datasource DS {
  // optionally set multiple providers
  // example: provider = ["sqlite", "postgresql"]
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = "native"
}

model Difficulty {
  name        String    @id
  color       String
  description String
  Problem     Problem[]
}

model TestCase {
  id        Int     @id @default(autoincrement())
  problem   Problem @relation(fields: [problemId], references: [id])
  problemId Int
  input     String
  output    String
}

enum Language {
  JAVASCRIPT
}

model Scaffold {
  id        String   @id
  problem   Problem  @relation(fields: [problemId], references: [id])
  problemId Int
  body      String
  language  Language
}

model Problem {
  id             Int        @id
  name           String
  description    String
  difficulty     Difficulty @relation(fields: [difficultyName], references: [name])
  difficultyName String
  hints          String[]
  sampleInput    String
  sampleOutput   String
  testCases      TestCase[]
  scaffolds      Scaffold[]
  checksum       String?
  entrypoints    Json?
}

model Solution {
  id            String    @id @default(uuid())
  body          String
  success       Boolean
  testCase      TestCase? @relation(fields: [testCaseId], references: [id]) // test case they failed if they failed
  testCaseId    Int?
  output        String? // output they got (wrong one)
  executionTime Int
  stacktrace    String?
  errorLogs     String[] // logs for test case the failed if failed
}

model Guild {
  id          String        @id @default(uuid())
  name        String
  experience  Int           @default(0)
  createdAt   DateTime      @default(now())
  Transaction Transaction[]
  users       User[]
}

// experience transactions
model Transaction {
  id      String   @id @default(uuid())
  guild   Guild?   @relation(fields: [guildId], references: [id])
  guildId String?
  delta   Int
  result  Int // total experience after delta
  time    DateTime @default(now())
  // todo: user id
  // transactions can exist for both users + guilds
}

model User {
  id      String  @id @default(uuid())
  name    String
  email   String  @unique
  guild   Guild?  @relation(fields: [guildId], references: [id])
  guildId String?
  level   Int
  title   Title   @relation(fields: [titleId], references: [id])
  titleId String
}

model Title {
  id          String @id @default(uuid())
  name        String
  users       User[]
  unlockLevel Int
}
